<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>CMemMapFile v1.57</title>
<link rel="stylesheet" type="text/css" href="./naughter.css">
</head>

<body>

<h2><img src="memmap.gif" width="42" height="42"
alt="CMemMapFile Logo">CMemMapFile v1.57</h2>

<p>Welcome to CMemMapFile, A freeware ATL based class to 
encapsulate memory mapped files.</p>

<p>&nbsp;</p>

<table border="0">
<TBODY>
  <tr>
    <td><a href="#Features">Features</a></td>
  </tr>
  <tr>
    <td><a href="#Usage">Usage</a></td>
  </tr>
  <tr>
    <td><a href="#Copyright">Copyright</a></td>
  </tr>
  <tr>
    <td><a href="#History">History</a></td>
  </tr>
  <tr>
    <td><a class="normal" href="#members">CMemMapFile class 
	members</a></td>
  </tr>
  <tr>
    <td><a href="#Contact">Contacting the Author</a></td>
  </tr>
</TBODY>
</table>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="Features"></a>Features 
</h2>

<p>Memory mapping is a powerful mechanism Win32 
provides to implement shared memory and also to access files though a simple 
memory pointer without having to implement your own home brewed buffering 
mechanisms. As an example its as simple as calling</p>

<p>void* lpData = mmf.Open();<br>
CharUpperBuff(static_cast&lt;LPSTR&gt;(lpData),dwFileLength);</p>

<p>to convert a file to upper case.</p>

<p>Areas where you might find this of interest 
include very large database files with fixed records, audio processing, string 
operations and image processing.</p>

<p>The other side of memory mapped files is to 
implement shared memory. As you will probably know, Win32 puts each process into 
its own address space, thus making it impossible to pass ordinary pointers 
across process boundaries. With memory mapped files you get back this very 
useful mechanism.</p>

<p>This class provides a simple MFC class interface 
and a simple dialog based application which demonstrates all the functionality 
of the class.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="Usage"></a>
Usage</h2>

<ul>
	<li>To use CMemMapFile in your project simply #include 
memmap.h from the test application in whichever files you want to use the class in.</li>
	<li>As of v1.53, the class is only supported on VC 2005 or later.</li>
	<li>Included in the download is a simple dialog based application which 
demonstrates the 2 main features of memory mapped files, namely mapping a file 
system file to a pointer and implementation of shared memory. For further 
details about the example program have a look at the BOOL CTestmemmapApp::InitInstance() function and the CDialog1 member functions both 
in testmemmap.cpp</li>
</ul>

<p>&nbsp;</p>
<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><b><a name="Copyright"></a>Copyright</b></h2>
<ul>
  <li>You are allowed to include the source code in any product (commercial, 
	shareware, freeware or otherwise) when your product is released in binary 
	form.</li>
  <li>You are allowed to modify the source code in any way you want except you 
	cannot modify the copyright details at the top of each module.</li>
  <li>If you want to distribute source code with your application, then you are 
	only allowed to distribute versions released by the author. This is to 
	maintain a single distribution point for the source code.</li>
</ul>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="History"></a>
History</h2>

<p><b>V1.0 (31 
March 1998)


</b>


<ul>
  <li>Class now avoids trying to lock the mutex if only read 
	access is required</li>
  <li>User now has the option of specifying whether a file 
	should be mapped with A Null terminator at the end. Can prove helpful when 
	you want to use some of the &quot;C&quot; runtime functions on the pointer returned.</li>
</ul>

<p><b>V1.1 (20 
April 1998)


</b>


<ul>
  <li>Now uses GetFileSize SDK call instead of 
	GetFileInformationByHandle as a more &quot;reliable&quot; way to determine file 
	length.</li>
  <li>Included TRACE statements to call GetLastError in all 
	places where SDK functions fail</li>
</ul>

<p><b>V1.2 (29 May 
1998)


</b>


<ul>
  <li>Mapping a file now has the option of making it named or 
	not.</li>
</ul>

<p><b>V1.3 (22 
October 1998)


</b>


<ul>
  <li>Fixed a bug in a number of calls to CreateMappingName 
	when the classes were being used to share memory.</li>
  <li>New documentation in the form of this HTML file.</li>
  <li>Sample now ships as standard with VC 5 workspace files</li>
  <li>Tidy up of the demo app including:<table border="0"
    width="68%">
      <tr>
        <td width="50%">Made the amount of text being shared 
		a constant of MAX_EDIT_TEXT instead of hardcoding it to 20 everywhere in 
		the sample.</td>
      </tr>
      <tr>
        <td width="50%">Changed where the timer is being 
		created to OnInitDialog</td>
      </tr>
      <tr>
        <td width="50%">Tidied up the initialisation sequence 
		in OnInitDialog</td>
      </tr>
      <tr>
        <td width="50%">Now using _tcscpy instead of _tcsncpy 
		to ensure array is null terminated</td>
      </tr>
      <tr>
        <td width="50%">Fixed resource.h which was causing 
		the resources to fail to compile</td>
      </tr>
      <tr>
        <td width="50%">Removed unnecessary symbols from 
		resource.h</td>
      </tr>
      <tr>
        <td width="50%">Optimised the way the OnTimer code 
		works to only update the text when it has changed in the MMF. This means 
		that you can type continuously into the edit control.</td>
      </tr>
    </table>
  </li>
</ul>

<p><b>V1.4 (30 
March 1999)


</b>


<ul>
  <li>Minor updates to the style of the help file.</li>
  <li>Code is now UNICODE compliant and build configurations 
	are provided.</li>
  <li>Code now supports growable memory mapped files as 
	provided with Windows 2000 and NTFS 5 volumes.</li>
  <li>Addition of accessor functions for file handle and file 
	mapping handle</li>
</ul>

<p><b>V1.41 (21 
April 1999)


</b>


<ul>
  <li>Added code to work around a Windows bug where you try 
	to memory map a zero length file on Windows 95 or 98.</li>
</ul>

<p><b>V1.42 (24 March 2000)
</b>
<ul>
  <li>Fixed a simple typo problem in a TRACE statement when 
	compiled for UNICODE</li>
</ul>

<p><b>V1.43 (7 March 2001)
</b>
<ul>
  <li>Updated copyright information.</li>
  <li>Fixed problem where mutex was not being locked when 
	read only access to the memory mapped file was desired. Access to the MMF 
	should be synchronised irrespective of the access mode.</li>
</ul>

<p><b>V1.44 (4 April 2001)
</b>
<ul>
  <li>Now supports passing in a security descriptor to 
	MapFile and MapMemory</li>
  <li>Now supports opening a specified portion of a file, 
	rather than always mapping all of the file</li>
</ul>

<p><b>V1.45 (5 October 2003)

</b>

<ul>
  <li>Updated copyright details.</li>
  <li>Fixed a small typo in the description of the 
	FSCTL_SET_SPARSE IOCTL. Thanks to amores perros for reporting this.</li>
  <li>Fixed a minor tab indentation problem at the start of 
	the MapFile method. Again thanks to amores perros for reporting this.</li>
  <li>Removed the unnecessary AssertValid function. Again 
	thanks to amores perros for reporting this.</li>
</ul>

<p><b>V1.46 (17 November 2003)

</b>

<ul>
  <li>Fixed a memory leak in UnMap as reported by Bart 
	Duijndam using &quot;Memory Validator&quot;. The memory leak may in fact not be real, 
	but the code change avoids the reported problem.</li>
</ul>

<p><b>V1.47 (6 June 2004)

</b>

<ul>
  <li>Fixed an issue in MapHandle where the wrong value was 
	sent to CreateFileMapping. This issue only occurs when you are not mapping 
	the whole of a file, but instead decide to perform the mapping a chunk at a 
	time. Thanks to Nicolas Stohler for reporting this problem.</li>
  <li>Removed the AppendNull option as it is incompatible 
	with general use of memory mapped files.</li>
  <li>Reviewed all the TRACE statements throughout the class</li>
  <li>Added ASSERT validation at the top of functions which 
	modify member variables</li>
  <li>Failing to create mutex in MapHandle and 
	MapExistingMemory not fails the function</li>
</ul>

<p><b>V1.48 (23 December 2004)
</b>
<ul>
  <li>Removed unnecessary include of winioctl.h header file.</li>
  <li>Fixed a problem with the declaration of the 
	FSCTL_SET_SPARSE macro which is used in the support of growable MMF. With 
	the VC6 WinIOCTL.h, the macro generates the value 0x000980C4, but the 
	correct value for the DeviceIoControl function to enable the sparse file 
	option is 0x000900C4. Thanks to a posting on CodeProject for pointing out 
	this problem.</li>
  <li>Optimized CMemMapFile::CreateMappingName by now using 
	CString::Replace.</li>
  <li>Addition of a bInheritHandle parameter to 
	MapExistingMemory.</li>
  <li>Fixed a bug in the handling of calls to GetFileSize()</li>
  <li>Removed unnecessary check to verify that mapping size 
	is greater than 4GB since CreateFileMapping will do this for us.</li>
  <li>Updated sample app to use a sample &quot;input.txt&quot; file for 
	demonstration purposes instead of using &quot;c:\config.sys&quot;</li>
  <li>Code now uses unsigned __int64 for specifying indexes 
	and lengths for memory mapping. This should allow the code to be easily used 
	to map &gt; 4GB on 64 bit versions of Windows.</li>
  <li>Tidied up some of the ASSERT code at the top of each 
	key function in the class.</li>
</ul>

<p><b>V1.49 (30 April 2005)
</b>
<ul>
  <li>Removed derivation from CObject MFC class. In fact the 
	class can now operate entirely independently of MFC.</li>
  <li>Destructor is now virtual.</li>
  <li>Fixed a bug where the mutex name which is used to 
	synchronize access to the MMF's data could by default have the same name for 
	multiple MMF's.</li>
  <li>CreateMappingName and CreateMutexName methods are now 
	virtual</li>
</ul>

<p><b>V1.50 (2 May 2006)
</b>
<ul>
  <li>Updated the copyright details in the modules.</li>
	<li>Updated the documentation to use the same style as the web site.</li>
	<li>Addition of a CMEMMAPFILE_EXT_CLASS macro to allow the class to be 
	easily incorporated into an extension dll.</li>
	<li>The sample app now uses filenames without &quot;(&quot; or &quot;)&quot; characters in their 
	filenames. Thanks to Andrew MacGinitie for reporting this issue.</li>
	<li>Fixed a bug in the sample app where it reports the wrong filename when 
	doing the lowercase conversion. Again thanks to Andrew MacGinitie for 
	reporting this issue.</li>
	<li>Fixed an issue in the download where the sample file called &quot;input.txt&quot; 
	is now provided out of the box. Again thanks to Andrew MacGinitie for 
	reporting this issue.</li>
	<li>Fixed an issue in the sample app when the code is compiled with /Wp64</li>
</ul>

<p><b>V1.51 (7 July 2006)
</b>
<ul>
	<li>Code now uses newer C++ style casts instead of C style casts.</li>
	<li>The code now requires the Platform SDK if compiled using VC 6.</li>
	<li>Updated code to compile cleanly using VC 2005.</li>
</ul>

<p><b>V1.52 (16 August 2008)
</b>
<ul>
	<li>Updated copyright details</li>
	<li>Code now compiles cleanly using Code Analysis (/analyze)</li>
	<li>Updated code to compile correctly using _ATL_CSTRING_EXPLICIT_CONSTRUCTORS 
	define</li>
	<li>The code now only supports VC 2005 or later. </li>
	<li>Removed VC 6 style AppWizard comments from the code.</li>
	<li>Updated the code to correctly handle &quot;Global\&quot; and &quot;Local\&quot; prefixes 
	which can be included with any Win32 Named object. Thanks to Gert Rijs for 
	reporting this bug. To achieve this the parameters to the MapFile method has 
	been reworked. This function now takes a pszMappingName which allows client 
	code to explicitly specify the mapping name</li>
	<li>The mutex name use to serialize access to the contents of the memory 
	mapped file is now explicitly provided as a external parameter to the class.</li>
	<li>MapExistingMemory now has a LPSECURITY_ATTRIBUTES parameter</li>
</ul>

<p><b>V1.53 (6 July 2009)</b></p>
<ul>
	<li>Updated copyright details </li>
	<li>Updated the sample apps project settings to more modern default values.
	</li>
	<li>All the failure paths in the methods now preserve the Win32 last error 
	value </li>
	<li>Removed unnecessary code to get the length of the file in MapFile. 
	Also simplified the logic in this method. </li>
	<li>All parameters which specify a mapping size now use a SIZE_T 
	parameter which is consistent with their equivalent API values. </li>
	<li>All calls to MapViewOfFile are now checked for failure </li>
</ul>

<p><b>V1.54 (20 November 2011)</b></p>
<ul>
	<li>Updated copyright details </li>
	<li>Updated code to clean compile on VC 2010 </li>
	<li>Replaced ASSERT calls with ATLASSERT </li>
	<li>Updated MapMemory and MapFile methods to include a new BOOL 
	bNoCache parameter. Thanks to HaeRim Lee for providing this nice update </li>
	<li>Removed m_bOpen member variable and all code which uses it. This 
	can avoid thread safety issues when a class instance of CMemMapFile is 
	shared across threads. Thanks to HaeRim Lee for providing this nice update
	</li>
	<li>Reworked the code in CMemMapFile::UnMap to call ReleaseMutex 
	directly instead of calling Close. This method now shares the same 
	consistent ordering of object creation / destruction as the main Map... 
	methods. This also fixes an issue where the mutex previously got released 
	twice. Thanks to HaeRim Lee for providing this nice update</li>
	<li>The whole class is now implemented in Memmap.h and the Memmap.cpp module 
	is now defunct and redundant. You now just need to #include the Memmap.h in 
	client code to use the class.</li>
</ul>

<p><b>V1.55 (25 November 2011)</b></p>
<ul>
	<li>Updated class to be completely MFC independent. You can now use CMemMapFile in an ATL only project. Thanks to HaeRim Lee for prompting this 
	update.</li>
</ul>

<p><b>V1.56 (15 March 2011)</b></p>
<ul>
	<li>Updated copyright details </li>
	<li>Made the class completely thread-safe meaning that you can share 
	instances of CMemMapFile across threads without worrying about corruption of 
	its member variables. Thanks to HaeRim Lee for prompting this update. To 
	achieve this I used a nested class called CMemMapCriticalSection which is 
	derived from the ATL::CCriticalSection class. This CMemMapCriticalSection 
	class provides for critical sections with spin locks and normal critical 
	sections as well as stack based release semantics for critical sections 
	through the use of the ATL::CComCritSecLock class. It would be nice if the 
	built in ATL CriticalSection class supported this but this is still not 
	present as of VC 2010 SP1. </li>
</ul>

<p><b>V1.57 (16 March 2011)</b></p>
<ul>
	<li>Thread protected the GetFileHandle and GetFileMappingHandle 
	methods. </li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="members"></a>CMemMapFile Class 
Members</h2>

<p><a href="#CMemMapFile">CMemMapFile</a><br>
<a href="#~CMemMapFile">~CMemMapFile</a><br>
<a href="#MapFile">MapFile</a><br>
<a href="#MapMemory">MapMemory</a><br>
<a href="#MapExistingMemory">MapExistingMemory</a><br>
<a href="#Open">Open</a><br>
<a href="#Close">Close</a><br>
<a href="#UnMap">UnMap</a><br>
<a href="#Flush">Flush</a><br>
<a href="#GetFileHandle">GetFileHandle</a><br>
<a href="#GetFileMappingHandle">GetFileMappingHandle</a></p>

<p>&nbsp;</p>

<p><b><a name="CMemMapFile"></a>
CMemMapFile::CMemMapFile </b> </p>

<p><strong>CMemMapFile(ULONG</strong> <em>nSpinCount</em> <strong>= 2000</strong>);</p>

<p><b>Remarks</b></p>

<p>Standard Constructor for the class.</p>

<p><b>Parameters</b></p>

<p><em>nSpinCount</em> is the spin count of the internal critical section which 
is used for thread synchronization internally in CMemMapFile</p>

<p>&nbsp;</p>

<p><b><a name="~CMemMapFile"></a>
CMemMapFile::~CMemMapFile </b> </p>

<p>~CMemMapFile();</p>

<p><b>Remarks</b></p>

<p>Standard destructor for the class. Calls the <a href="#UnMap">
UnMap</a>
function</p>

<p>&nbsp;</p>

<p><b><a name="MapFile"></a>CMemMapFile::MapFile </b> </p>

<p><b>BOOL MapFile(LPCTSTR </b> <em>pszFilename</em><b>, 
BOOL </b> <em>bReadOnly</em><b> = FALSE, DWORD </b> <em>dwShareMode</em><b>
= 0, LPCTSTR </b> <em>pszMappingName</em><b>
= NULL, LPCTSTR </b><em>pszMutexName</em><b>
= NULL, BOOL </b> <em>bGrowable</em><b> = FALSE, const 
unsigned __int64&amp; </b><i>dwStartOffset<b> </b> </i><b>= 0, const SIZE_T&amp;
</b><i>
nNumberOfBytesToMap<b> </b> </i><b>= 0, LPSECURITY_ATTRIBUTES </b> <i> 
lpSecurityAttributes<b> </b> </i><b>= NULL, BOOL </b><i> 
bNoCache<b> </b> </i><b>= FALSE);</b></p>

<p><b>Return Value</b></p>

<p>TRUE if the file was successfully mapped otherwise FALSE</p>

<p><b>Parameters</b></p>

<p><em>sFilename</em> is the filename to memory map</p>

<p><em>bReadOnly</em> can be set to true if you are not 
interested in modifying the file</p>

<p><em>dwShareMode</em> is the share flags to use when 
calling CreateFile. This may be prove useful if you want to map a file using MMF 
techniques but allow other processes access to it as read only</p>

<p><em>pszMappingName</em> is the Win32 name of the memory mapping you want to 
create. Normally when
you map a file there is no need to do this as the memory mapping is not being used to share 
memory and you can leave this value as NULL</p>

<p><em>pszMutexName</em> is the Win32 name of the mutex used to serialize access 
to the memory mapping</p>

<p><em>bGrowable</em> If you set this value to TRUE, then the 
underlying file will be set to be a &quot;sparse&quot; file. In the context of memory 
mapped files, this means that you will not get access violations when you try to 
write past the end of the file, instead the OS will silently grow the file for 
you. Please note that this is only supported on NTFS 5 volumes on Windows 2000 
or later. This could be useful where you want to use memory mapped files to 
implement features such as direct to disk audio recording where you do not want 
to pre-allocate a certain size disk file up front</p>

<p><i>dwStartOffset </i>The offset into the file at which you 
want the file mapping to start</p>

<p><i>nNumberOfBytesToMap</i> The number of bytes you would 
like to map. The default value of 0 means that all the file will be mapped</p>

<p><i>lpSecurityAttributes</i> Allows NT security attributes 
to be associated with this file mapping</p>
<p><em>bNoCache</em> If set to TRUE, then the SEC_NOCACHE flag is passed to the 
CreateFileMapping function</p>

<p><b>Remarks</b></p>

<p>Maps a file system file. Note that an attempt to modify a file mapping when 
it is in read only mode will generate an access violation</p>

<p>&nbsp;</p>

<p><b><a name="MapMemory"></a>
CMemMapFile::MapMemory </b> </p>

<p><b>BOOL MapMemory(LPCTSTR </b> <i>pszMappingName</i><b>, LPCTSTR </b> <i>
pszMutexName</i><b>, 
const SIZE_T&amp; </b> <em>nBytes</em><b>, BOOL </b> <em>
bReadOnly</em><b> = FALSE,                   
LPSECURITY_ATTRIBUTES </b> <i> lpSecurityAttributes<b> </b>
</i><b>= NULL, BOOL </b><i> 
bNoCache<b> </b> </i><b>= FALSE);</b></p>

<p><b>Return Value</b></p>

<p>TRUE if the memory was successfully mapped otherwise FALSE</p>

<p><b>Parameters</b></p>

<p><em>pszMappingName</em> is the Win32 name of the memory mapping you want to 
create</p>

<p><em>pszMutexName</em> is the Win32 name of the mutex used to serialize access 
to the memory mapping</p>

<p><i>nBytes</i> is the size to map</p>

<p><em>bReadOnly</em> is as in <a href="#MapFile">MapFile</a></p>

<p><i>lpSecurityAttributes</i> Allows NT security attributes 
to be associated with this file mapping</p>
<p><em>bNoCache</em> If set to TRUE, then the SEC_NOCACHE flag is passed to the 
CreateFileMapping function</p>

<p><b>Remarks</b></p>

<p>This creates a piece of shared memory</p>

<p>&nbsp;</p>

<p><b><a name="MapExistingMemory"></a>
CMemMapFile::MapExistingMemory
</b>
</p>

<p><b>BOOL MapExistingMemory(LPCTSTR </b><i>pszMappingName</i><b>, LPCTSTR </b> 
<i>pszMutexName</i>,<b> const SIZE_T&amp; </b> <em>nBytes</em><b>, 
BOOL <em>bReadOnly</em> = FALSE, BOOL </b> <i>
bInheritHandle<b> </b> </i> <b>= FALSE, LPSECURITY_ATTRIBUTES </b> <i> lpSecurityAttributes<b> </b>
</i><b>= NULL);</b></p>

<p><b>Return Value</b></p>

<p>TRUE if the memory was successfully mapped otherwise FALSE</p>

<p><b>Parameters</b></p>

<p><em>pszMappingName</em> is the Win32 name of the memory mapping you want to 
create</p>

<p><em>pszMutexName</em> is the Win32 name of the mutex used to serialize access 
to the memory mapping</p>

<p><i>nBytes</i> is the size to map</p>

<p><em>bReadOnly</em> is as in <a href="#MapFile">MapFile</a></p>

<p><i>bInheritHandle</i> Specifies if the handle is to be 
inherited by a new process during process creation</p>
<p><i>lpSecurityAttributes</i> Allows NT security attributes 
to be associated with this file mapping</p>

<p><b>Remarks</b></p>

<p>This function is quite similar to <a href="#MapMemory">
MapMemory</a>
except that it fails it the mapping is already created. This function can be 
used to connect to existing shared memory or where you want to detect if this is 
the first instance of your program to run</p>

<p>&nbsp;</p>

<p><b><a name="Open"></a>CMemMapFile::Open </b> </p>

<p><b>LPVOID Open(DWORD </b> <em>dwTimeout</em><b> 
= INFINITE);</b></p>

<p><b>Return Value</b></p>

<p>Pointer to the data as stored in the memory mapped file</p>

<p><b>Parameters</b></p>

<p><em>dwTimeout</em> The dwTimeout value is the time in milliseconds to wait if 
the mapping is already opened by another thread or process</p>

<p><b>Remarks</b></p>

<p>Once you have called <a href="#MapFile">MapFile</a>, <a
href="#MapMemory">MapMemory</a> or <a href="#MapExistingMemory">
MapExisitingMemory</a> you can call this function to actually get a pointer to 
the data. Internally the class uses a mutex to synchronise access to the memory 
so that you do not have to worry about thread synchronisation problems when 
using the class. . If you use the default value then your thread will be 
suspended indefinitely if another thread is using the object.</p>

<p>&nbsp;</p>

<p><b><a name="Close"></a>CMemMapFile::Close </b> </p>

<p><b>BOOL Close();</b></p>

<p><b>Remarks</b></p>

<p>This is the corollary of the <a href="#Open">Open</a> 
function and there should be a matching call to Close for each call to Open. 
After calling close you are free to call Open again to get back the pointer</p>

<p>&nbsp;</p>

<p><b><a name="UnMap"></a>CMemMapFile::UnMap </b> </p>

<p><b>void UnMap();</b></p>

<p><b>Remarks</b></p>

<p>This unmaps the object and releases all the file handles and synchronisation 
objects. You can consider this function to be the corollary to the Map...() 
functions. This function is also called in the destructor if you forget to do it 
yourself</p>

<p>&nbsp;</p>

<p><b><a name="Flush"></a>CMemMapFile::Flush</b></p>

<p><b>BOOL Flush();</b></p>

<p><b>Return Value</b></p>

<p>Returns TRUE if the flush was successful otherwise FALSE</p>

<p><b>Remarks</b></p>

<p>Flushes the mapping object to disk.</p>

<p>&nbsp;</p>

<p><b><a name="GetFileHandle"></a>
CMemMapFile::GetFileHandle</b></p>

<p><b>HANDLE GetFileHandle()</b></p>

<p><b>Return Value</b></p>

<p>Returns the file handle which this memory mapping instance 
encapsulates. This value returned will be INVALID_HANDLE_VALUE if it is called 
on a memory mapping which is being used to share memory rather than a file on 
the file system.</p>

<p>&nbsp;</p>

<p><b><a name="GetFileMappingHandle"></a>
CMemMapFile::GetFileMappingHandle</b></p>

<p><b>HANLDE GetFileMappingHandle();</b></p>

<p><b>Return Value</b></p>

<p>Returns the file mapping handle which this memory mapping 
instance encapsulates.</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<p>&nbsp;</p>

<h2><a name="Contact"></a>Contacting the Author</h2>

<p>PJ Naughter<br>
Email: <a href="mailto:pjna@naughter.com">pjna@naughter.com</a><br>
Web: <a href="http://www.naughter.com">http://www.naughter.com</a><br>
16 March 2012</p>
</body>
</html>