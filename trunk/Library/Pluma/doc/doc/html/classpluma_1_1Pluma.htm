<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>Pluma - Plug-in Management Framework</title>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="tabs.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div id="logo">
            <img src="./logo.png" title="Pluma home" alt="Pluma logo" />
        </div>
<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>pluma</b>      </li>
      <li class="navelem"><a class="el" href="classpluma_1_1Pluma.htm">Pluma</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">pluma::Pluma Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="pluma::Pluma" --><!-- doxytag: inherits="pluma::PluginManager" -->
<p><a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> plugins management.  
 <a href="classpluma_1_1Pluma.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Pluma_8hpp_source.htm">Pluma.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pluma::Pluma:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpluma_1_1Pluma.png" usemap="#pluma::Pluma_map" alt=""/>
  <map id="pluma::Pluma_map" name="pluma::Pluma_map">
<area href="classpluma_1_1PluginManager.htm" title="Manages loaded plugins." alt="pluma::PluginManager" shape="rect" coords="0,0,137,24"/>
</map>
 </div></div>

<p><a href="classpluma_1_1Pluma-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1Pluma.htm#adf4e065f5169931f6290f3828b49e7bb">Pluma</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="#adf4e065f5169931f6290f3828b49e7bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ProviderType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluma_1_1Pluma.htm#a73e15a18747b5efeb917b021c7a6f8e6">acceptProviderType</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> to accept a certain type of providers.  <a href="#a73e15a18747b5efeb917b021c7a6f8e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ProviderType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluma_1_1Pluma.htm#a8e6f84a44a4d286ab25056072abb3d34">getProviders</a> (std::vector&lt; ProviderType * &gt; &amp;providers)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stored providers of a certain type.  <a href="#a8e6f84a44a4d286ab25056072abb3d34"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a73e15a18747b5efeb917b021c7a6f8e6"></a><!-- doxytag: member="pluma::Pluma::acceptProviderType" ref="a73e15a18747b5efeb917b021c7a6f8e6" args="()" -->
template&lt;typename ProviderType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>acceptProviderType</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e6f84a44a4d286ab25056072abb3d34"></a><!-- doxytag: member="pluma::Pluma::getProviders" ref="a8e6f84a44a4d286ab25056072abb3d34" args="(std::vector&lt; ProviderType * &gt; &amp;providers)" -->
template&lt;typename ProviderType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getProviders</b> (std::vector&lt; ProviderType * &gt; &amp;providers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6">load</a> (const std::string &amp;path)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin given it's path.  <a href="#aa00400d23efa8a8f94e44dd1c5bf54e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#a866127044950094bb789260bc15a2874">load</a> (const std::string &amp;folder, const std::string &amp;pluginName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a plugin from a given folder.  <a href="#a866127044950094bb789260bc15a2874"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#a4d892e345288c26dea091d62ee2b03eb">loadFromFolder</a> (const std::string &amp;folder, bool recursive=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all plugins from a given folder.  <a href="#a4d892e345288c26dea091d62ee2b03eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#a52f6408d4cf95c6f36b518ab2d3a7745">unload</a> (const std::string &amp;pluginName)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload a plugin.  <a href="#a52f6408d4cf95c6f36b518ab2d3a7745"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#a697a20dc97957e0c2a5dad33f39d93db">unloadAll</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload all loaded plugins.  <a href="#a697a20dc97957e0c2a5dad33f39d93db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#af27f8e89b8e29359495b6398464ebf02">addProvider</a> (<a class="el" href="classpluma_1_1Provider.htm">Provider</a> *provider)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly add a new provider.  <a href="#af27f8e89b8e29359495b6398464ebf02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#a187e60d3fe7524774c08eb58ebcb843f">getLoadedPlugins</a> (std::vector&lt; const std::string * &gt; &amp;pluginNames) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of all loaded plugins.  <a href="#a187e60d3fe7524774c08eb58ebcb843f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#adbd75738cd4d8969608c9da8b58a03c3">isLoaded</a> (const std::string &amp;pluginName) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a plug-in is loaded.  <a href="#adbd75738cd4d8969608c9da8b58a03c3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#ab70b5b6b719bdbd64c27ae2dcb12a64d">registerType</a> (const std::string &amp;type, unsigned int version, unsigned int lowestVersion)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a provider type.  <a href="#ab70b5b6b719bdbd64c27ae2dcb12a64d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="classpluma_1_1Provider.htm">Provider</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluma_1_1PluginManager.htm#ab019b967f514cf504d8ac1aadf481ffd">getProviders</a> (const std::string &amp;type) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get providers of a certain type.  <a href="#ab019b967f514cf504d8ac1aadf481ffd"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> plugins management. </p>
<p><a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> is the main class of <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> library. Allows hosting applications to load/unload dlls in runtime (plugins), and to get providers of shared interface objects.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">pluma::Pluma</a> pluma;
 <span class="comment">// Tell it to accept providers of the type DeviceProvider</span>
 pluma.<a class="code" href="classpluma_1_1Pluma.htm#a73e15a18747b5efeb917b021c7a6f8e6" title="Tell Pluma to accept a certain type of providers.">acceptProviderType</a>&lt;DeviceProvider&gt;();
 <span class="comment">// Load some dll</span>
 pluma.<a class="code" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6" title="Load a plugin given it&#39;s path.">load</a>(<span class="stringliteral">&quot;plugins/standard_devices&quot;</span>);
 <span class="comment">// Get device providers into a vector</span>
 std::vector&lt;DeviceProvider*&gt; providers;
 pluma.<a class="code" href="classpluma_1_1Pluma.htm#a8e6f84a44a4d286ab25056072abb3d34" title="Get the stored providers of a certain type.">getProviders</a>(providers);
 <span class="comment">// create a Device from the first provider</span>
 <span class="keywordflow">if</span> (!providers.empty()){
     Device* myDevice = providers.first()-&gt;create();
     <span class="comment">// do something with myDevice</span>
     std::cout &lt;&lt; device-&gt;getDescription() &lt;&lt; std::endl;
     <span class="comment">// (...)</span>
     <span class="keyword">delete</span> myDevice;
 }
</pre></div><p>It is also possible to add local providers, providers that are defined directly on the host application. That can be useful to provide and use default implementations of certain interfaces, along with plugin implementations. </p>

<p>Definition at line <a class="el" href="Pluma_8hpp_source.htm#l00094">94</a> of file <a class="el" href="Pluma_8hpp_source.htm">Pluma.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adf4e065f5169931f6290f3828b49e7bb"></a><!-- doxytag: member="pluma::Pluma::Pluma" ref="adf4e065f5169931f6290f3828b49e7bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pluma::Pluma </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default Constructor. </p>

<p>Definition at line <a class="el" href="Pluma_8inl_source.htm#l00027">27</a> of file <a class="el" href="Pluma_8inl_source.htm">Pluma.inl</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a73e15a18747b5efeb917b021c7a6f8e6"></a><!-- doxytag: member="pluma::Pluma::acceptProviderType" ref="a73e15a18747b5efeb917b021c7a6f8e6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProviderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pluma::Pluma::acceptProviderType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tell <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> to accept a certain type of providers. </p>
<p>A <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> object is able to accept multiple types of providers. When a plugin is loaded, it tries to register it's providers implementations. Those are only accepted by the host application if it's accepting providers of that kind.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ProviderType</td><td>type of provider. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af27f8e89b8e29359495b6398464ebf02"></a><!-- doxytag: member="pluma::Pluma::addProvider" ref="af27f8e89b8e29359495b6398464ebf02" args="(Provider *provider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluma::PluginManager::addProvider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluma_1_1Provider.htm">Provider</a> *&#160;</td>
          <td class="paramname"><em>provider</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directly add a new provider. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">provider</td><td><a class="el" href="classpluma_1_1Provider.htm" title="Interface to provide applications with objects from plugins.">Provider</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a187e60d3fe7524774c08eb58ebcb843f"></a><!-- doxytag: member="pluma::Pluma::getLoadedPlugins" ref="a187e60d3fe7524774c08eb58ebcb843f" args="(std::vector&lt; const std::string * &gt; &amp;pluginNames) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluma::PluginManager::getLoadedPlugins </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const std::string * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pluginNames</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of all loaded plugins. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginNames</td><td>A vector to fill with the plugins names. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e6f84a44a4d286ab25056072abb3d34"></a><!-- doxytag: member="pluma::Pluma::getProviders" ref="a8e6f84a44a4d286ab25056072abb3d34" args="(std::vector&lt; ProviderType * &gt; &amp;providers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProviderType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pluma::Pluma::getProviders </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; ProviderType * &gt; &amp;&#160;</td>
          <td class="paramname"><em>providers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the stored providers of a certain type. </p>
<p>Providers are added at the end of the <em>providers</em> vector.</p>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">ProviderType</td><td>type of provider to be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">providers</td><td>Vector to fill with the existing providers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab019b967f514cf504d8ac1aadf481ffd"></a><!-- doxytag: member="pluma::Pluma::getProviders" ref="ab019b967f514cf504d8ac1aadf481ffd" args="(const std::string &amp;type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt;<a class="el" href="classpluma_1_1Provider.htm">Provider</a>*&gt;* pluma::PluginManager::getProviders </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get providers of a certain type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td><a class="el" href="classpluma_1_1Provider.htm" title="Interface to provide applications with objects from plugins.">Provider</a> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the list of providers of that <em>type</em>, or NULL if <em>type</em> is not registered.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Host::getProviders </dd></dl>

</div>
</div>
<a class="anchor" id="adbd75738cd4d8969608c9da8b58a03c3"></a><!-- doxytag: member="pluma::Pluma::isLoaded" ref="adbd75738cd4d8969608c9da8b58a03c3" args="(const std::string &amp;pluginName) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluma::PluginManager::isLoaded </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if a plug-in is loaded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>the plug-in tname o check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a866127044950094bb789260bc15a2874"></a><!-- doxytag: member="pluma::Pluma::load" ref="a866127044950094bb789260bc15a2874" args="(const std::string &amp;folder, const std::string &amp;pluginName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluma::PluginManager::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a plugin from a given folder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">folder</td><td>The folder path. </td></tr>
    <tr><td class="paramname">pluginName</td><td>Name of the plugin. File extension may be included, but is discouraged for better cross platform code. If file extension is omitted, <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> will deduce it from the operating system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the plugin is successfully loaded.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6" title="Load a plugin given it&#39;s path.">load(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a4d892e345288c26dea091d62ee2b03eb" title="Load all plugins from a given folder.">loadFromFolder</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a52f6408d4cf95c6f36b518ab2d3a7745" title="Unload a plugin.">unload</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a697a20dc97957e0c2a5dad33f39d93db" title="Unload all loaded plugins.">unloadAll</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa00400d23efa8a8f94e44dd1c5bf54e6"></a><!-- doxytag: member="pluma::Pluma::load" ref="aa00400d23efa8a8f94e44dd1c5bf54e6" args="(const std::string &amp;path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluma::PluginManager::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load a plugin given it's path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path for the plugin, including plugin name. File extension may be included, but is discouraged for better cross platform code. If file extension isn't present on the path, <a class="el" href="classpluma_1_1Pluma.htm" title="Pluma plugins management.">Pluma</a> will deduce it from the operating system.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the plugin is successfully loaded.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classpluma_1_1PluginManager.htm#a866127044950094bb789260bc15a2874" title="Load a plugin from a given folder.">load(const std::string&amp;, const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a4d892e345288c26dea091d62ee2b03eb" title="Load all plugins from a given folder.">loadFromFolder</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a52f6408d4cf95c6f36b518ab2d3a7745" title="Unload a plugin.">unload</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a697a20dc97957e0c2a5dad33f39d93db" title="Unload all loaded plugins.">unloadAll</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4d892e345288c26dea091d62ee2b03eb"></a><!-- doxytag: member="pluma::Pluma::loadFromFolder" ref="a4d892e345288c26dea091d62ee2b03eb" args="(const std::string &amp;folder, bool recursive=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pluma::PluginManager::loadFromFolder </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load all plugins from a given folder. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">folder</td><td>Path for the folder where the plug-ins are. </td></tr>
    <tr><td class="paramname">recursive</td><td>If true it will search on sub-folders as well</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of successfully loaded plug-ins.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classpluma_1_1PluginManager.htm#a866127044950094bb789260bc15a2874" title="Load a plugin from a given folder.">load(const std::string&amp;, const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6" title="Load a plugin given it&#39;s path.">load(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a52f6408d4cf95c6f36b518ab2d3a7745" title="Unload a plugin.">unload</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a697a20dc97957e0c2a5dad33f39d93db" title="Unload all loaded plugins.">unloadAll</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab70b5b6b719bdbd64c27ae2dcb12a64d"></a><!-- doxytag: member="pluma::Pluma::registerType" ref="ab70b5b6b719bdbd64c27ae2dcb12a64d" args="(const std::string &amp;type, unsigned int version, unsigned int lowestVersion)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluma::PluginManager::registerType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lowestVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a provider type. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td><a class="el" href="classpluma_1_1Provider.htm" title="Interface to provide applications with objects from plugins.">Provider</a> type. </td></tr>
    <tr><td class="paramname">version</td><td>Current version of that provider type. </td></tr>
    <tr><td class="paramname">lowestVersion</td><td>Lowest compatible version of that provider type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Host::registerType </dd></dl>

</div>
</div>
<a class="anchor" id="a52f6408d4cf95c6f36b518ab2d3a7745"></a><!-- doxytag: member="pluma::Pluma::unload" ref="a52f6408d4cf95c6f36b518ab2d3a7745" args="(const std::string &amp;pluginName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pluma::PluginManager::unload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pluginName</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload a plugin. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginName</td><td>Name or path of the plugin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the plugin is successfully unloaded, false if no such plugin exists on the manager.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classpluma_1_1PluginManager.htm#a866127044950094bb789260bc15a2874" title="Load a plugin from a given folder.">load(const std::string&amp;, const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6" title="Load a plugin given it&#39;s path.">load(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a4d892e345288c26dea091d62ee2b03eb" title="Load all plugins from a given folder.">loadFromFolder</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a697a20dc97957e0c2a5dad33f39d93db" title="Unload all loaded plugins.">unloadAll</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a697a20dc97957e0c2a5dad33f39d93db"></a><!-- doxytag: member="pluma::Pluma::unloadAll" ref="a697a20dc97957e0c2a5dad33f39d93db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pluma::PluginManager::unloadAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unload all loaded plugins. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classpluma_1_1PluginManager.htm#a866127044950094bb789260bc15a2874" title="Load a plugin from a given folder.">load(const std::string&amp;, const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#aa00400d23efa8a8f94e44dd1c5bf54e6" title="Load a plugin given it&#39;s path.">load(const std::string&amp;)</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a4d892e345288c26dea091d62ee2b03eb" title="Load all plugins from a given folder.">loadFromFolder</a> </dd>
<dd>
<a class="el" href="classpluma_1_1PluginManager.htm#a52f6408d4cf95c6f36b518ab2d3a7745" title="Unload a plugin.">unload</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Pluma_8hpp_source.htm">Pluma.hpp</a></li>
<li><a class="el" href="Pluma_8inl_source.htm">Pluma.inl</a></li>
</ul>
</div>

        <p id="footer">
            &nbsp;::&nbsp; Copyright &copy; 2011 Gil Costa, all rights reserved &nbsp;::&nbsp;
            Documentation generated by <a href="http://www.doxygen.org/" title="doxygen website">doxygen 1.7.4</a> &nbsp;::&nbsp;
        </p>

    </body>
</html>
